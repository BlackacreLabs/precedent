module Precedent
  grammar Inline
    rule inline
      first:(word / space / emphasis / smallcaps)
      subsequent:(single_newline? (word / space / emphasis / smallcaps))*
      {
        def build
          ret = subsequent.elements.map(&:build).flatten.reduce([first.build]) do |mem, e|
            last = mem.last
            if e.nil?
              mem
            elsif last.is_a?(String) && e.is_a?(String)
              mem + [mem.pop + e]
            else
              mem + [e]
            end
          end
          ret.count == 1 ? ret.first : ret
        end
      }
    end

    rule smallcaps
      '<<' content:inline '>>'
      {
        def build
          { :type => :smallcaps, :content => content.build }
        end
      }
    end

    rule emphasis
      '//' content:inline '//'
      {
        def build
          { :type => :emphasis, :content => content.build }
        end
      }
    end

    rule single_newline
      "\n" { def build ; ' ' ; end }
    end

    rule word
      [a-zA-Z.]+ { def build ; text_value ; end }
    end

    rule space
      ' ' { def build ; ' ' ; end }
    end
  end
end
